\epigraph{\itshape Randomized testing exemplifies the 80/20 rule: it yields 80\% of the benefit
of formal verification for 20\% of the effort.}{Matt Might}

\QuickCheck es una biblioteca de Haskell para hacer pruebas generadas aleatoriamente que deben
cumplir ciertas propiedades nuestros programas. El programador provee una especificación de su
programa en la forma de propiedades las cuales las funciones deben satisfacer y, \QuickCheck prueba
que esas propiedades se mantengan en un gran número de casos de casos generados aleatoriamente. Las
especificaciones son expresadas en Haskell usando combinadores proporcionados por \QuickCheck.
\QuickCheck provee combinadores para definir propiedades, observar la disctribución de los casos
de prueba y, definir los generadores de información generadores.\footnote{
    Descripción de \QuickCheck tomada de la documentación oficial\\
    \url{https://hackage.haskell.org/package/QuickCheck}.
}

\noindent\rule{\textwidth}{1pt}

En esta sección se verá la importancia sobre usar \QuickCheck; tanto como una manera rápida de
verificar ciertas propiedades que deben cumplirse en alguna implementación que se haya hecho en
Haskell, ventajas y desventajas sobre su uso. El porqué es útil utilizarlo y qué problemática
aborda.

Se verá como será utilizado en un ejemplo práctico; en este caso tanto en
\hyperlink{funcional:funcion_error}{la funsión de error} y en
\hyperlink{funcional:kmp}{\textit{Knuth-Morris-Pratt}} en Haskell. En ambos ejemplos se expondrá la
versión \textit{naïve} y la versión ``optimizada'' que fue derivada mediante razonamiento
ecuacional. Y por medio de casos generados aleatoriamente se analizará el resultado que
\QuickCheck proporciona.

\section{Motivación}
Hoy en día el estilo de hacer pruebas a nuestro código es mediante \textit{pruebas unitarias (unit
testing)} en las cuales; se inveta un ``estado del mundo'', se ejecuta la prueba unitaria, se
checa si el estado modificado del ``mundo'' hace lo que debería hacer y al final se ve si todo
sigue funcionando como se debe.

A continuación se muestra un conjunto de aserciones (\texttt{assert}) en Java para ejemplificar
la idea. Una aserción puede ser utilizada para verificar si una suposición hecha durante la
implementación del programa se mántiene válida cuando el programa es ejecutado.

\begin{minted}[frame=lines, framesep=10pt, linenos]{java}
public class TestAdder {
    public void testSum() {
        Adder adder = new AdderImpl();
        assert(adder.add(1, 1) == 2);
        assert(adder.add(1, 2) == 3);
        assert(adder.add(2, 2) == 4);
        assert(adder.add(0, 0) == 0);
        assert(adder.add(-1, -2) == -3);
        assert(adder.add(-1, 1) == 0);
        assert(adder.add(1234, 988) == 2222);
    }
}

interface Adder {
    int add(int a, int b);
}
class AdderImpl implements Adder {
    public int add(int a, int b) {
        return a + b;
    }
}
\end{minted}

En este tipo de pruebas se pueden agregar gran cantidad de objetos que simulan comporamientos 
(\textit{mock objects}) o, un sinnúmero de casos prueba pero ¿cuál es el problema aquí? El código
anterior solo tiene 7 pruebas y no es dificil de imaginar que se pueden crear muchos más casos, o
simplemente si se implementa otra funcionalidad el espacio de búsqueda de posibles \textit{bugs}
crece de forma exponencial.

Claramente hacer pruebas es impráctico, pero ¿por qué usar \QuickCheck?
\begin{itemize}
\item Se pueden combinar las pruebas basadas en propiedades (en la siguiente sección se hablará
de esto) con casos de prueba generados \textit{aleatoriamente}.
\item El programador escribe propiedades a cumplir en vez de pruebas en específico.
\item Obviamente no nos puede dar la misma seguridad de hacer pruebas exhaustivamente, pero
\textbf{es muy práctico}.
\item Se puede escoger la cantidad de información que será sometida a nuestras propiedades.
\end{itemize}


\section{Uso básico}

Consideremos la siguiente propiedad de la función \hsCode{reverse} para \textit{listas finitas}.
\begin{minted}{haskell}
import Test.QuickCheck

prop_rev_rev :: [Int] -> Bool
prop_rev_rev xs = reverse (reverse xs) == xs
\end{minted}

Después de haber importado \hsCode{Test.QuickCheck}, se carga la definición en \texttt{ghci}
para después invocarlas
\begin{minted}{text}
>>> quickCheck prop_rev_rev
+++ OK, passed 100 tests.
\end{minted}

Y aunque esta propiedad es verdadera y más adelante se muestra su demostración, se puede
ver lo útil y práctico que es.
% TODO: Poner prueba de StructuralInduction.pdf página 9

Ahora consideremos un caso donde la propiedad falle \QuickCheck mostrará un contraejemplo.
\begin{minted}{haskell}
prop_wrong :: [Int] -> Bool
prop_wrong xs = reverse xs == xs 
\end{minted}

Mostrando así un caso donde no cumple la propiedad.
\begin{minted}{text}
>>> quickCheck prop_rev_id
*** Failed! Falsified (after 5 tests and 3 shrinks):
[1,0]
\end{minted}

\noindent\rule{\textwidth}{1pt}

Veamos otro ejemplo, para todo entero $n$, si $n$ es par entonces $n+1$ es impar. Aunque la
demostracióon es trivial, con \QuickCheck se puede validar (mas no verficar formalmente) con
varios números generados aleatoriamente para probar esta propiedad.
\begin{minted}{haskell}
>>> quickCheck (\n -> even n ==> odd(n + 1))
+++ OK, passed 100 tests
\end{minted}

donde \hsCode{==>} es una propiedad condicional que descarta los casos que no satisfacen esa
precondición.

Cuando se escriben propiedades;
\begin{itemize}
\item Las propiedades simples son función que son funciones booleanas.
\item La conveción es que los nombres de las propiedades tienen el prefijo \hsCode{prop_}.
\item Los parámetros están ímplicitamente cuantificados con un cuantificador universal $\forall$ y
la última y más importante es que las funciones polimórficas deben de estar restringidas a un tipo
en específico.
\end{itemize}


\section{Generadores}

Aunque \QuickCheck puede generar algunos valores aleatorios para algún tipo ímplicitamente, hay
ocaciones que se necesita nuestros propios valores aleatorios. Es aquí cuando se debe escribir
una instancia de \hsCode{Arbitrary} para esto. Los valores que se ocupan en la pruebas son
producidos por los \textit{generadores de valores}.

Los Generadores tienen tipos de la forma \hsCode{Gen a} que es un generador de valores para
un tipo \hsCode{a}. El tipo \hsCode{Gen} es una mónada, así que se puede utilizar la notación 
\hsCode{do} y las funciones monádicas pueden ser utilizadas para definir generadores.

Veamos el siguiente ejemplo; consideremos el tipo de dato algebraico \hsCode{Point} donde
representa un punto en un espacio bidimensional. Lo que se quiera hacer es generar puntos
con coordenadas $x$ y $y$ aleatoriamente.

\begin{minted}{haskell}
data Point = Point Int Int

instance Arbitrary Point where
  arbitrary = do
    x <- arbitrary
    y <- arbitrary
    return (Point x y)
\end{minted}

donde \hsCode{arbitrary :: Gen a} es un generator para valores de un cierto tipo, y que en este
caso son de tipo \hsCode{Int}.

\section{Probando las implementaciones}

Es aquí cuando las versiones \emph{naïve} y las obtenidadas por medio de razonamiento ecuacional,
tanto en la \hyperlink{funcional:funcion_error}{función de error} como en
\hyperlink{funcional:kmp}{\textit{Knuth-Morris-Pratt}} son probadas uno a uno con diferentes casos
prueba en Haskell.

Al hacer los casos prueba usando el tipo \hsCode{String} es poco probables tener
\textit{una buena disctribución} de los caracteres que comprende la cadena y, en especial en probar
el algoritmo KMP con las cadenas del patrón y texto. Si por ejemplo restringimos las cadenas
a que solo contengan caracteres ASCII aún así no serían muy útiles en las pruebas. Consideremos
el siguiente ejemplo.

\begin{minted}{haskell}
>>> sample $ vectorOf 10 arbitraryASCIIChar
\end{minted}
La función \hsCode{sample :: Show a => Gen a -> IO ()} genera algunos valores de ejemplo y los
imprime en la slaida estándar. Si se toma un valor que se imprimió que por ejemplo sería
\mintinline{text}|"\t\n]*]i_\fm\SYN"| se ve que no es muy útil para nuestro propósito. Pero
¿no sería más mejor definir nuestros propios valores aleatorios?

\hfill \break
En los generadores presentados a continuación en la función de error y el algoritmo KMP es
bastante usual que se trabaje sobre alfabeto finito $\Sigma$; puede ser sobre las letras del
alfabeto $\Sigma = \{ \texttt{a} \ldots \texttt{z} \}$, un alfabeto binario $\Sigma = \{ 0, 1 \}$
o un alfabeto de ADN donde $\Sigma = \{ \texttt{A,C,G,T} \}$.

\newpage
\inputminted[frame=lines, framesep=10pt, linenos]{haskell}
    {codigo/haskell/test-failure-function.hs}

\begin{itemize}
\item En la línea \texttt{3} y \texttt{4} se importan los módulo de la versión de error, tanto
la versión que tiene complejidad $O(n^3)$ y $\Theta(n)$ respectivamente que proveerán la función
\hsCode{ptable} que es la función de error.
\item En la línea \texttt{6} del módulo \hsCode{Data.Array} solo se importa la función\\
\hsCode{elems :: Array i e -> [e]} para obtener una lista de elementos del arreglos en el orden
indexado.
\item En la línea \texttt{8} se hace una envoltura (\emph{wrapper}) para un \hsCode{String} con el
constructor \hsCode{S}. Éste será usado para poder usar la instancia de \hsCode{Arbitrary}.

Mucho mejor definir un nuevo tipo isomorfo a (en este caso) \hsCode{String} y así poder definir
su generador por defecto para éste para usos específicos.
\item En la línea \texttt{11} a \texttt{15}, para poder usar \hsCode{arbitrary} es el tipo
\hsCode{Pattern} definido por nosotros, se necesita declar como instancia de \hsCode{Arbitrary}.
En la línea \texttt{12} por medio de la notación \hsCode{do} cada línea será un valor monádico,
primero se liga el valor \hsCode{size} a un número aleatorio entre 1 y 1000 con\\
\hsCode{chooseInt :: (Int, Int) -> Gen Int} que genera un elemento aleatorio dado un rango
inclusivo, acto seguido se liga la variable \hsCode{text} con una cadea del tamaño de la variable
\hsCode{size} sobre un alfabeto de la letra \hsCode{'a'} a la \hsCode{'z'} con
\hsCode{vectorOf :: Int -> Gen a -> Gen [a]} que genera una lista de una longitud dada. Finalmente
con la función \hsCode{return} pone el resultado en un contexto monádico.
\item En la línea \texttt{17} no es necesario que sea instancia de \hsCode{Show}, pero con
\hsCode{verboseCheck} en \hsCode{QuickCheck} es útil para poder mostar los casos prueba.
\item De la línea \texttt{22} y \texttt{24}
% TODO: explicarlo propiamente que es eso de que requresa bool y lo que saco del constructor
% poner como se llama lo que hace let e iin
en la línea se transforma lo que devuelve la función \hsCode{ptable} a una lista de tipo
\hsCode{[(Char, Int)]} donde la $i$-ésima posición donde la primera entrada es el $i$-ésimo caracter
de la cadena de  y la segunda entrada es la $i$-ésima posiición de la función de error.
En la línea \texttt{23}, lo que regresa \hsCode{FailureFunctionOptimizedp.ptable} regresa
\hsCode{Array Int (a, Int)} pero con la función \hsCode{A.elems} se obtiene un lista que finalmente
en la línea \texttt{24} see compara que ambas listas sean iguales.
\end{itemize}

% TODO: ver si ocupo esto: \hsCode{elements :: [a] -> Gen a} Genera un elemento de los valores dados. La lista debe ser no vacía.

\texttt{\$ runhaskell test-matching.hs}

\begin{minted}{text}
Testing NaiveMatching with MP1...
+++ OK, passed 100 tests.
Testing MP1 with MP2...
+++ OK, passed 100 tests.
Testing MP2 with KMP...
+++ OK, passed 100 tests.
Testing NaiveMatching with KMP...
+++ OK, passed 100 tests.
\end{minted}

\begin{minted}{text}
Passed:
jwvtllqfgknosijmqccjmpwrfjjbaxgqakfhkxvhwjgukoeoipneicodymknicywsrwjwiz
rzoeufakcwyojquaugelxiujdbrexedtmsqhoofquvrucbvvwmjpbeeamiajfrrruvwjixl
pvrrntqyxyopxyoynhpghrknnrikcukgyjamnngkytmqmdmydzqeendgktbltsfdqwhjfhn
cnroyrelnsskwereataldovaxpneqmvnjaxengwvlknppfzrlmvpyeatvhvbatesajcfpcf
upltdezxedaggbhavklpiyjzwk

Passed:
ovfpnmsesopulhcnpjzhsubeuwfsrvcrktozf

Passed:
lgcnmiwzyvtlkpsuukuemwawrdptrulmchwmtqkknymyfnyurmobjhgkpcfrxbxfxhjerks
mehenlcjjwbbkzhxdotgxwasmxgwpmsnhlsoyfshqclxscaxytdwywxozhvqpbkshf

Passed:
wmdtscgkwkkuuxwqmmvdexwvtdplthvgtjbcacxmnncqlnzhfnskrfaynnvcogyqllfkzcc
gwtuyjxlstlrvphafeajgjwwahyqnqgfutvtsfqeqiulljouzkjgvtwgrrnhfpznugyawox
ypqwiubmkylfhrwnbdfkhbnnqpnrmebivpbypkswtnrrmitdgxwqjmfoetqhwuqbbghvmko
wscxbzdl

Passed:
ruhtwpwesozzglmsvzzshonujhutwjkagfhzbdvsdiczpeuzxgwmkugjgpbynlp

...
...
...

+++ OK, passed 100 tests.

\end{minted}

% TODO: poner que cambié a verboseCheck

% TODO: acabar el ejemplo de abajo
\newpage
\inputminted[frame=lines, framesep=10pt, linenos]{haskell}
    {codigo/haskell/test-matching.hs}
\begin{itemize}
\item En la línea \texttt{3}, \texttt{4}, \texttt{5} y \texttt{6}
\item En la línea \texttt{8}
\item En la línea \texttt{11}
\item En la línea \texttt{19}
\item foo %TODO: poner en todos los "prop"
\end{itemize}

\begin{minted}{text}
Testing NaiveMatching with MP1...
Passed:
Pattern:GCCGAACCATCGAGTGTATC
Text:TAAGACAATTCAACTCCGAGCTGCGCGGCGCAGTTTGTCACAGTGTGGGGGTGGCAGCTACCCCCTAAG
CGTTATTTATTGGTGTACGCTGAGTATCACAATATTCCACCACCCTCCGTTATGGTTAGTTGATAGAAATTCGA
CCGATGTTTGATTCTTCTAAAGCCAGTGTAACTGCGGATAAGCTGGCTTGG

Passed:
Pattern:CCA
Text:TGCATTAGCGGGTGAGGAGCTCTACGCTTCGCTTTCAGCTTTAAACGATTATGTGCGGTCACCCCAATT
GTCTTATGATGGCCAATATTTCGTCAGTACCACTTCAGTGGCATGACTGAGTGACGCA

Passed:
Pattern:C
Text:CACCACGCCGATTCCTGGTCGTTACCTTAGCCAAATAGACTTAAGTGTTGCTTGACCTGTC

Passed:
Pattern:CGTTGTG
Text:GGGTATCATGACTCCGAAGGATTTGTGACGTTGTGAGGATTTACACCCCGTGAGTCGATCTTTCCTGGT
CTTGATGATGAGATGCGGCACGAAGGTAGGGACTACTTAAGAGGGTCGCTCAAGTAGGATCTGGACGTGTACAG
ACTATCACACCTCTCGCGCCGTACTACTGTTAATCCCCTCTCTCTTGCCATCTGAGCTAGCGCTCAGCTCGATA
TTTGTTTTATA

Passed:
Pattern:AG
Text:AAAAGCGGAACTCAATCTGCCAAGCGCCCGAGCACCTGTGGCCTCGCACTGTGGTGGCGAAGTGTTAAG
GCATGAACCTTATGCCGTAGCAACTTGCACACATACTTTGCATCTAACCTCCACTTAATCCGCGGCGATTGCAT

...
...
...

+++ OK, passed 100 tests.

Testing MP1 with MP2...
Passed:
Pattern:TACGCTTCCGCCTCGTAT
Text:GGTTGCTACACCCCGTCTGCCACCGATACATGGTAGCACTACTTAGCTATGGAGTCCGAAAGAAACCAG
GTATCCGGTAGAATGGATTTAGCGAGGTAATAGGGTCCAGCTTTCAAGCTCAACCCATC

Passed:
Pattern:AGG
Text:CCCGGCTATTGTCCCAAAGCATGATCATAACTTCAAGCTGTGTCCCCTTCTCAGTCGGACAGCGCTAGA
ATCCGCCCGTAGGCAGAACGAAGTGATCGATTTACAGTGTTTTGAAAAGGCCGTCCTGAAACACGCGTCTGTTA
TGTAATTGTGGTATCTTCTACTAGATTTGTGTCATCA

...
...
...

+++ OK, passed 100 tests.

Testing MP2 with KMP...
Passed:
Pattern:CCC
Text:CCTCGACAACAGGTATTCAAGTGTGCATCCATCTTATAGAAGTACATTCAATAACCGTCTAAGCTGCTG

Passed:
Pattern:CGG
Text:AGGCCAGAGCCATTGAACTGAAGAAATAAAGCGTGGCACGACGCACCACCTGCCGCATCTCTCGGCGCA
CACGTTGTGTCTGTGTCCGGTAAAAAATACATATAATCCATACATGTT

...
...
...

+++ OK, passed 100 tests.

Testing NaiveMatching with KMP...
Passed:
Pattern:CCGCATCTGGAGTGG
Text:TCCTGACGGATGAATAGTCTGCCCGACGATTCTTGCTTGACTGCTTATGGTGGTACACTCGTAGAGGGT
GGGGACGTGCTTCAGACCTTAACAGCTTATCGTCTCTGTGTGAACGGTACACGCGACGATACATCGTCCGTAGG
ATTTGCACGGGCGTTCCGCATCTGGAGTGGCTAGATTCAGTTGTAA

Passed:
Pattern:TCA
Text:TCGGAAGGCGACGAGTGCGATAAGAGTCAGCAATAGTTGTGCCTAAGCCATATGATGCCAGACCGCCGTCATCACTCTCGTAGTCAGGCACTTGAGCTTAAGGTTATCAATTTATCGGGTATTTTTGACATGGCAGGTAAGGGGGATCGCTTTAGCATGTTAGTAACCCGAAAGACATGATTTTGACATCTCACACGTAGTTATGGAAGCAACTGCCCTACGGCTCCAGGCGAGCCAACTGCGCCTAGTGGGTGTGCCTGCGCTTAACGACCACTGATTGGTTAGTCTGATCCACGAGGGCGGCCAAGGACAAGCATAGACCTGGGCCCCCCTCGGTGCGGCACTAAGATATATCCTGATGGACCACCGATATTTTAATGTGGGCACCTACAGGATTCATATGTCAATTATACGATAGATAAAGGATGACCGGGACACACATCGA

...
...
...

+++ OK, passed 100 tests.
\end{minted}

% TODO: revisar si lo que escribí hace sentido.