En diversas situaciones se necesita encontrar todas las ocurrencias de un patrón en un texto;
éstas pueden ir desde editores de texto hasta buscar patrones particulares en secuencias de ADN.
Es aquí cuando se hace uso de algoritmos eficientes para este problema.

Es aquí cuando se formaliza el problema de ``búsqueda de subcadenas'' (string-matching).
Supongamos que el texto es un arreglo $T[1 \ldots n]$ de longitud $n$ y el patrón es un arreglo
$P[1 \ldots m]$ de longitud $m \leq n$. También supongamos que los elementos de $P$ y $T$ son
caracteres tomados de un alfabeto finito $\Sigma$. El arreglo de caracteres $P$ y $T$ también son
llamados \textbf{cadenas} de caracteres.

\section{Notación y terminología}

Decimos que el patrón $P$ \textbf{ocurre con un desplazamiento} $s$ en el texto $T$ si
$0 \leq s \leq n - m$ y $T[s+1 \ldots s+m] = P[1 \ldots m]$. Si $P$ ocurre con un desplazamiento
$s$ en $T$, entonces se dice que $s$ es \textbf{un desplazamiento válido}, si no, se dice que $s$
es \textbf{un desplazamiento inválido}.
El \textbf{problema de búsqueda de subcadenas} es el problema de encontrar todos los
desplazamientos válidos en los que dado el patrón $P$ ocurre en el ttexto $T$.

% aquí poner la imagen del la figura 32.1 y explicarlo

Denotemos a $\Sigma^*$ como el conjunto de todas las cadenas de longitud finita formadas usando
caracteres del alfabeto $\Sigma$. La cadena de longitud cero es \textbf{la cadena vacía}, denotada
como $\varepsilon$, que también pertenece a $\Sigma^*$. La longitud de una cadena $x$ se denota
como $\vert x \vert$. La \textbf{concatenación} de dos cadenas $x$ y $y$, se denota como $xy$ y
tiene como longitud $\vert x \vert + \vert y \vert$ y consiste de los caracteres de $x$ seguidos
por los caracteres de $y$.

Decimos que una cadena $w$ es \textbf{prefijo} de una cadena $x$, denotada como $w \sqsubset x$, si
$x = wy$ para alguna cadena $y \in \Sigma^*$. Notemos que si $w \sqsubset x$, entonces
$\vert w \vert \leq \vert x \vert$. De manera análoga, decimos que una cadena $w$ es \textbf{sufijo}
de una cadena $x$, denotado como $w \sqsupset x$, si $x = yw$ para alguna $y \in \Sigma^*$. Y así
como con el prefijo, si $w \sqsubset x$, entonces $\vert w \vert \leq \vert x \vert$.
Por ejemplo, tomemos \texttt{ab $\sqsubset$ abcca} y \texttt{cca $\sqsupset$ abcca}. La cadena
vacía $\varepsilon$ es tanto un sufijo coomo un prefijo para cualquier cadena.

\section{Algoritmo de búsqueda de subcadenas ingenuo (\textit{naïve})}

\begin{algorithm}[H]
    \SetKwProg{Fn}{NAIVE-STRING-MATCHER($T,P$)}{}{}
    \Fn{}{
        $n = T.length$\\
        $m = T.length$\\
        \For{$s = 0 $ \KwTo $n-m$}{
            \If{$P[1\ldots m] == T[s+1 \ldots s+m]$}{
                $print$ ``Pattern occurs with shift'' $s$
            }
        }
    }
\end{algorithm}

\section{Algoritmo Knuth-Morris-Pratt}
% TODO: ver qué agarro de aquí: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm

\subsection{Diferencias entre KMP Y MP}
% TODO: https://www.cs.helsinki.fi/u/tpkarkka/teach/14-15/SPA/lecture04.pdf
% https://studylib.net/doc/7580926/chapter-6-the-mp-and-kmp-algorithms--algorithms-based-upon

% http://www-igm.univ-mlv.fr/~lecroq/string/node7.html#SECTION0070
%http://www-igm.univ-mlv.fr/~lecroq/string/node8.html

\begin{algorithm}[H]
    \SetKwProg{Fn}{KMP-MATCHER($T,P$)}{}{}
    \Fn{}{
        $n = T.length$\\
        $m = T.length$\\
        $\pi =$ COMPUTE-PREFIX-FUNCTION($P$)\\
        $q = 0$\\    
        \For{$i = 1 $ \KwTo $n$}{
            \While{$q >0$ and $P[q+1] \neq T[i]$}{
                $q = \pi[q]$
            }
            \If{$P[q+1] == T[i]$}{
                $q = q + 1$
            }
            \If{$q == m$}{
                $print$ ``Pattern occurs with shift'' $i-m$\\
                $q = \pi[q]$
            }
        }
    }
\end{algorithm}


\begin{algorithm}[H]
    \SetKwProg{Fn}{COMPUTE-PREFIX-FUNCTION($P$)}{}{}
    \Fn{}{
        $m = P.length$\\
        let $\pi[1 \ldots m]$ be a new array\\
        $\pi[1] =0$\\
        $k = 0$\\    
        \For{$q = 2 $ \KwTo $m$}{
            \While{$k >0$ and $P[k+1] \neq P[q]$}{
                $k = \pi[k]$
            }
            \If{$P[k+1] == P[q]$}{
                $k = k + 1$
            }
            $\pi[k] = k$
        }
        \Return $\pi$
    }
\end{algorithm}

\subsection{Problemas}

\begin{tcolorbox}
\hypertarget{repetition_factor}{32.1 a.}
\textbf{String matching based on repetition factors}
Let $y^i$ denote the concatenation of string y with itself $i$ times. For example,
\texttt{ab}$^3 =$ \texttt{ababab}. We say that a string $x \in \Sigma^*$
\textbf{has repetition factor} $r$ if $x = y^r$ for some string $y \in \Sigma^*$ and some $r > 0$.
Let $\rho(x)$ denote the largest $r$ such that $x$ has repetition factor $r$.
Give an efficient algorithm that takes as input a pattern $P[1 \ldots m]$ and computes the value
$\rho(x)$ for $i = 1,2,\ldots,m$. What is the running time of your algorithm?
\end{tcolorbox}

Lo primero que se debe de hacer es calcular la función de error $\pi$ teniendo una complejidad en
tiempo de $\Theta(m)$ y lineal en espacio. Teniendo calculada $\pi$, consideremos $m$ la longitud
del patrón y supongamos que $r = m - \pi[m]$ es la longitud de la $i$-esima raíz del patrón y que
$\pi[i] = i - r$ donde $r \mid m$ es la $\frac{i}{k}$-ésima concatenación de la raíz del patrón
hasta la $i$-ésima posición. Conlcuyendo así que $\rho(P) = \frac{m}{r}$.

En otro caso, supongamos que no se cumple lo anterior, i.e., que $r \nmid m$ entonces su factor de
repetición forzosamente debe ser 1. Por contradicción, supongamos que tiene un factor de repetición
mayor estrico que 1 lo que significaría que tendría que habría una cadena $y^r$ y que
$\pi[i] \geq \vert x^{r-1} \vert$, pero significaría que podríamos escribir a $x$ concatenada $r$
veces. $\Rightarrow\!\Leftarrow$.


\begin{tcolorbox}
\hypertarget{cyclic_rotation}{32.4-7}   
Give a linear-time algorithm to determine whether a text $T$ is a cyclic rotation of another string
$T'$ . For example, \texttt{arc} and \texttt{car} are cyclic rotations of each other.
\end{tcolorbox}

Descartemos el caso en que la longitud de $T$ y $T'$ sean diferentes porque no podría ser una
rotación cíclica. Entonces $\vert T \vert = \vert T' \vert$, sea $S = TT$ el texto donde $T$ está
concatenado dos veces, y $P = T'$ el patrón. Usando el algoritmo de Knuth-Morris-Pratt se buscará
el patrón $P$ en $S$ en tiempo lineal.

Supongamos que $P$ aparece en $T$ desplazado $s$ posiciones a la izquierda donde
$0 \leq s < \vert P \vert$. Si $s = 0$ entonces $T = T'$, el caso interesante es cuando $s > 0$,
teniendo así que $T[0 \ldots s]$ es sufijo de $T'$ y $T[s+1 \ldots m]$ es prefijo de $T$. 

\noindent\rule{\textwidth}{1pt}

Los problemas anteriores se obtuvieron del libro \textit{Introduction to Algorithms, Third
Edition}\cite{cormen_2009}, pero en el \autoref{chap:jueces} se verá que éstos mismos problemas
pueden llegar a aparecer en problemas de programación competitiva, por lo que no basta con
``memorizar los algoritmos'' como muchos podrían llegar a pensar.

\section{Diferentes tipos de algoritmos en cadenas}
