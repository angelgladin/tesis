En este capítulo se derivará por medio de una especificación formal la función de error del
algoritmo de KMP. Aunque por medio de este acercamiento\cite{bird:cyclic} se podría obtener todo
el algoritmo KMP usando estructuras cíclicas, específicameente listas doblemente ligadas, no se
hará así, porque se verá otra manera ``puramente funcional'' de hacerlo en el siguiente capítulo.

Consideremos la cadena \texttt{abacabab} y su procesamiento con la función de error,

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|}
\cline{2-9}
$k$      & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          \\ \hline
$P[k]$   & \texttt{a} & \texttt{b} & \texttt{a} & \texttt{c} & \texttt{a} & \texttt{b} & \texttt{a} & \texttt{b} \\ \hline
$\pi[k]$ & 0          & 0          & 1          & 0          & 1          & 2          & 3          & 2          \\ \cline{2-9} 
\end{tabular}
\end{table}

La entrada $\pi[k]$ en la posición $b$ es la longitud del \textbf{sufijo propio más largo} de
\hsCode{take k "abacabab"} que también es un prefijo de \hsCode{"abacabab"}.

Veamos del procesamiento de la cadena de arriba:
\begin{itemize}
\item[$\pi{[1]}$] Dado que el sufijo propio más largo de \hsCode{take 1 "abacabab" = "a"} es
$\varepsilon$, siempre la primera posición será 0. Por lo que $\pi[1] = 0$.
\item[$\pi{[2]}$] El sufijo propio más largo de \hsCode{take 2 "abacabab" = "ab"} que también es
prefijo de \texttt{abacabab} es $\varepsilon$. Por lo que $\pi[2] = 0$.
\item[$\pi{[3]}$] El sufijo propio más largo de \hsCode{take 3 "abacabab" = "aba"} que también es
prefijo de \texttt{abacabab} es \texttt{a}. Por lo que $\pi[3] = 1$.
\item[$\pi{[4]}$] El sufijo propio más largo de \hsCode{take 4 "abacabab" = "abac"} que también es
prefijo de \texttt{abacabab} es $\varepsilon$. Por lo que $\pi[4] = 0$.
\item[$\pi{[5]}$] El sufijo propio más largo de \hsCode{take 5 "abacabab" = "abaca"} que también
es prefijo de \texttt{abacabab} es \texttt{a}. Por lo que $\pi[5] = 1$.
\item[$\pi{[6]}$] El sufijo propio más largo de \hsCode{take 6 "abacabab" = "abacab"} que también
es prefijo de \texttt{abacabab} es \texttt{ab}. Por lo que $\pi[6] = 2$.
\item[$\pi{[7]}$] El sufijo propio más largo de \hsCode{take 7 "abacabab" = "abacaba"} que también
es prefijo de \texttt{abacabab} es \texttt{aba}. Por lo que $\pi[7] = 3$.
\item[$\pi{[8]}$] El sufijo propio más largo de \hsCode{take 8 "abacabab" = "abacabab"} que también
es prefijo de \texttt{abacabab} es \texttt{ab}. Por lo que $\pi[8] = 2$.
\end{itemize}

Para una lista no vacía \texttt{as}, los sufijos \textbf{propios} de \hsCode{take k as} son sufijos
de \hsCode{take (k-1) (tail as)}, el $k-1$ es porque como se afirma que la lista \texttt{as} es no
vacía, se contemplan en los sufijos propios a la lista vacía, y a \hsCode{tail as} de manera
similar.

Teniendo así una forma de calcular todos los sufijos \textbf{propios} de una lista \texttt{as} como:
\begin{minted}{haskell}
[take (k - 1) (tail as) | k <- [1 .. length as]] = inits (tail as)
\end{minted}

De igual manera se mostrará por medio de un ejemplo concreto tales sufijos propios,
\begin{minted}{haskell}
>>> inits (tail "abacabab")
    inits "bacabab"
    ["","b","ba","bac","baca","bacab","bacaba","bacabab"]
\end{minted}

donde \hsCode{inits}\footnote{
    La función \hsCode{inits} viene definida en el módulo \hsCode{Data.List}.
    }
regresa una lista con los prefijos de una lista en orden creciente y \hsCode{tail} extrae la cabeza
de la lista.

La función de error se define como:
\inputminted[fontsize=\small]{haskell}{codigo/haskell/FailureFunctionNaive.hs}

Donde \hsCode{llasp as bs} es la longitud del sufijo más largo de \texttt{bs} que es también un
prefijo de \texttt{as}. Esto es porque la función \hsCode{tails}\footnote{
    La función \hsCode{tails} viene definida en el módulo \hsCode{Data.List}.
    }
regresa todos los sufijos en orden decreciente y con la función \hsCode{head} solo se obtiene el
primero (que evidentemente es el mayor). Y así \hsCode{ptable} calcula la función de error como
una lista.

Si se calcula \hsCode{ptable "abacabab"} el resultado es:
\begin{minted}{haskell}
>>> ptable "abacabab"
    [(1,('a',0)),(2,('b',0)),(3,('a',1)),(4,('c',0)),(5,('a',1)),
     (6,('b',2)),(7,('a',3)),(8,('b',2))]
\end{minted}

Recordando el \textit{Scan Lemma}\ref{fundamentos:scan_lemma} y viendo que hay un \hsCode{inits} en
\hsCode{ptable} veamos si se puede optimizar. El \textit{Scan Lemma} afirma que
\begin{minted}{haskell}
map (foldl op e) . inits = scanl op e
\end{minted}

Para expresar a \hsCode{llasp as bs} en la forma de un pliegue \hsCode{foldl (op as) e} se debe
demostrar que: % TODO: The universal property of fold

\begin{minted}{haskell}
llsap as []          = e
llsap as (bs ++ [b]) = op as (llsap as bs) b
\end{minted}
Para una definición adecuada de \hsCode{e} y \hsCode{op}. 

Es inmediato que \hsCode{llsap as [] = 0} porque el sufijo \texttt{[]} que es prefijo de
\texttt{as} es de longitud 0 y así \texttt{e = 0}.

Lo interesante es encontrar \hsCode{op}. Sea\hsCode{ k = llsap as bs} donde \texttt{k} y\\
\hsCode{ a = head (drop k as)}, así \texttt{a} es el siguiente elemento de \texttt{as} después del
prefijo más largo de \texttt{as} que se empareja con el sufijo de \texttt{bs}.

Para ejemplificarlo consideremos los siguientes ejemplos sobre la cadena original \texttt{abacabab}.
\begin{itemize}
\item Consideremos $i = 3$ donde\hsCode{ bs = take 3 "abacabab" = "aba"},\\
\hsCode{llsap "abacabab" "a" = 1}\\
\hsCode{head (drop 1 "abacabab") = head "bacabab" = 'b' = a}.
Y así \texttt{a\colorbox{yellow}b}\texttt{acabab}.
\item Consideremos $i = 6$ donde\hsCode{ bs = take 6 "abacabab" = "abacab"},\\
\hsCode{llsap "abacabab" "ab" = 2}\\
\hsCode{head (drop 2 "abacabab") = head "acabab" = 'a' = a}.
Y así \texttt{ab\colorbox{yellow}a}\texttt{cabab}.
\end{itemize}

Si \texttt{a = b}, entonces \hsCode{llsap as (bs ++ [b]) = k+1} porque % TODO: explicar

Si no, \texttt{k = 0} entonces \hsCode{llsap as (bs ++ [b]) = 0} porque % TODO: porque no hay sufifo que sea prefijo

En el caso que queda se tiene % TODO: explicar que es porque, pero en sí es porque es un segmento de bs es un segmento de take (k-1) as
\begin{minted}{haskell}
llsap as (bs ++ [b]) = llsap as (take (k - 1) (tail as) ++ [b])
\end{minted}

Así \texttt{llasp as bs = foldl (op as) bs}, donde
\begin{minted}{haskell}
op as k b  | a == b    = k + 1
           | k == 0    = 0
           | otherwise = llsap as (take (k - 1) (tail as) ++ [b])
               where a = head (drop k as)
\end{minted}

% TODO: quitar esto de los backpointers, es más ni lo usi
Ahora viene la parte donde la representación de la tabla de apuntadores \textit{back} como un arreglo en vez de una lista
resulta útil. Poniendo \texttt{xa = ptable as}, se puede ver que,

% TODO: decir que aquí usaré ya arrays
\begin{minted}{haskell}
head (drop k as)                        = fst (xa!(k + 1))
llsap as (take (k - 1) (tail as) ++ [b] = op as (llsap as (take (k - 1) (tail as))) b
                                        = op as (snd (xa!k)) b
\end{minted}

% TODO: poner paso intermeedio de lista a arreglo.
Recordando que \hsCode{xa} es 1-indexada. Esto significa que \hsCode{ptable} queda redefinida como


\inputminted{haskell}{codigo/haskell/FailureFunctionOptimized.hs}
