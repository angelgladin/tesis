\label{chap:prog_competitiva}
\epigraph{\itshape Talk is cheap. Show me the code.}{Linus Torvalds}

Cuando se habla acerca del término `programación competitiva' se refiere a: ``Dados problemas
bien conocidos en Ciencias de la Computación, ¡resolverlos tan pronto como sea posible!''.
\cite{halim2013competitive} Otras personas suelen llamarlo un deporte mental.

Desglosemos el significado término por término. El término `problemas bien conocidos en Ciencias de
la Computación', implica que en programación competitiva se está trantando con problemas que
ya han sido resultos y \textbf{no} con problemas de investigación o abiertos (donde las
soluciones siguen siendo desconocidas). El término `resolverlos' implica que se debe usar nuestro
conocimiento en Ciencias de la Computación a un nivel en el que se produzca código que funcione y
que resuelva el problema también, al menos en el contexto de obtener la misma \textit{salida} que
el autor del problema, usando el conjunto de información secreta\footnote{
    Se refiere a que se esconde cierta información de la especificación del problema. La
    programación competitiva fomenta a quienes resuelven los problemas ejercitar su fortaleza
    mental en pensar en todos los posibles casos extremos en sus problemas y probar sus programas
    con ésos casos}
de entrada de prueba, dentro de un tiempo estipulado. La necesidad de resolver el problema `tan
pronto como sea posible' es donde entra el elemento de competitividad ``la velocidad es un
meta muy natural en el comporamiento humano''. \par

En concursos de la ICPC\footnote{
    \say{La Competición Internacional Universitaria de Programación (en inglés International
    Collegiate Programming Contest, abreviado \textbf{ICPC}) es una competición anual de
    programación y algorítmica entre universidades de todo el mundo, donde prima el trabajo en
    equipo, el análisis de problemas y el desarrollo rápido de software.}\cite{eswiki:135765381}
} o IOI\footnote{
    \say{La Olimpiada Internacional de Informática es una más de las Olimpiadas Internacionales
    de Ciencias, que tiene como objetivo potenciar el aprendizaje de la informática en alumnos de
    secundaria y preparatoria (nivel medio y medio superior). Los problemas de esta competición
    están orientados a los algoritmos.}\cite{eswiki:125950903}
} (por mencionar algunos de los concursos más importantes) a los concursantes se les da un conjunto
de problemas entre 5 a 12 problemas de diferentes tipos; \emph{ad hoc}, búsqueda
completa, \emph{divide y vencerás}, \emph{greedy}, \textbf{programación dinámica}, teoría
de gráficas, matemáticas (teoría de números, probabilidad, teoría de juegos, etc), procesamiento
de cadenas, geometría computacional y algunos tópicos raros/avanzados (en general problemas NP).
Y esto por mencionar alguna clasificación, que sin dudarlo se podrían agregar más o entrar más a
detalle.

\section{Análisis del algoritmo}
Siempre que se diseña el algoritmo para un problema en particular de una competencia uno debe
preguntarse lo siguiente: dados los límites de los datos de entrada, el algoritmo que se diseñó
¿pasará las restricciones de tiempo y espacio dados?
Esto es porque puede que haya varias formas de atacar el problema, desde hacerlo de una manera
incorrecta, hasta resolverlo de una manera óptima o que solo sea lo ``suficientemente buena''.
Una buena estrategia a seguir es \textbf{tomar la solución más simple que funcione}, es decir,
lo ``suficientemente buena'' para que solucione (y se acepte) el problema.

Una regla empírica que es usada, es que las computadoras de hoy en día pueden procesar hasta cien
millones de operaciones (ó $10^8$) en \textit{unos pocos segundos}. Y justo esa información es la
que se usa para saber si el algoritmo diseñado se ejecutará en ese tiempo.

Por ejemplo, si el tamaño $n$ máximo de la entrada es $100K$ (ó $10^5$), y el algoritmo que fue
diseñado o usado tiene una complejidad de $O(n^2)$, entonces se tendría que $10^{10}$ es un número
\emph{muy grande} y que el algoritmo tardaría cientos de segundos para acabar. Entonces es aquí
cuando uno debe de idear un algoritmo más rápido (y también correcto) que resuelva el problema.
Supóngase que se encontró un algoritmo con complejidad en tiempo de $O(n \log_2 n)$, lo cual
es $\approx 1.6 \times 10^6$ que bastante seguro que será capaz de pasar el tiempo límite.

Las \emph{cotas} (\emph{constraints}) del problema son tan importantes como la complejidad del
tiempo del algoritmo para determinar si su solución es apropiada. Supongamos que se propone un
algoritmo bastante sencillo de implementar que se ejecuta con una complejidad de $O(n^4)$. A pesar
de que parezca una solución muy mala, si se tiene que $n \leq 50$ es ``lo suficientemente buena''
para que resuelva el problema.

Una buena heurística a seguir en este mundo de la programación competitiva es tomar la tabla de
abajo para tener en cuenta la complejidad del algoritmo propuesto y el tiempo que tomará\footnote{
    Se asume que una CPU puede ejecutar alrededor de $100M$ de operaciones en 3 segundos.
}.
\begin{table}[H]
\centering
\begin{tabular}{l|l}
\hline
$n$                   & Peor caso en el que se acepta el algoritmo  \\ \hline
$\leq [10 \ldots 11]$ & $O(n!), \; O(n^6)$                          \\
$\leq [15 \ldots 18]$ & $O(2^n \times n^2)$                         \\
$\leq [18 \ldots 22]$ & $O(2^n \times n)$                           \\
$\leq 100$            & $O(n^4)$                                    \\
$\leq 400$            & $O(n^3)$                                    \\
$\leq 2K$             & $O(n^2 \log_2 n)$                           \\
$\leq 10K$            & $O(n^2)$                                    \\
$\leq 1M$             & $O(n \log_2 n)$                             \\
$\leq 100M$           & $O(n), \; O(\log_2 n), \; O(1)$             \\ \hline
\end{tabular}
\label{cap5:tabla:complejidades}
\end{table}

\section{Anatomía de los problemas}

En las competencias de programación la mayoría de los problemas tienen los siguientes componentes:

\begin{itemize}
\item \textbf{Historia de fondo o descripción del problema.} Por lo general los problemas más
fáciles estás escritos de una manera \emph{engañosa} para parecer más difíciles de lo que son en
los concursos, por ejemplo agregando mucha información innecesaria. Los concursantes deben de
ser capaces de saber distiguir qué información es la útil para la resolución del problema. Sin
embargo, los problemas difíciles están escritos de la manera más sencilla posible, porque ya
son lo suficientemente difíciles como para que llegara a haber aún más ambigüedades.

\item \textbf{Descripción del I/O.} Aquí es cuando se dan detalles de como será el formato de la
entrada y como se debe de presentar la salida. En la gran mayoría de veces están escrita de la
manera más formal posible. Un \emph{buen problema} debe indicar de manera \textbf{clara} las cotas 
(en la literatura en inglés se le conoce como \emph{constraints}) de la entrada para así poder
tener en cuenta la complejidad del algoritmo a usar.

\item \textbf{Muestra del I/O.} Los autores del problema simpre dan casos de prueba triviales. Esto
se hace para que los concursantes vean si se entendió el problema y verificar si su código puedo
procesar la entrada dada y producir la salida deseada.

\item \textbf{Pistas.} En algunos casos el autor del problema llegan a dar pistas para resolver
el problema.

\end{itemize}

\section{Presentación (I/O)}

En las competencias de programación, la correctud del código está determinada en ser probado
sobre muchos casos prueba. Muchos casos de prueba vienen incluidos en un solo archivo. A
continuación\footnote{
    Se exhibirán dos pedazos de código; en el lado izquierdo se mostrará cómo hacerlo en Haskell
    y del lado derecho en C++. 
    En Haskell se excplicará la anatomía del código.

    Posteriormente se muestra cómo debe ser la entrada y salida.
} se muestran los tres formatos de I/O más usados:

\begin{enumerate}
\pagebreak
\item \label{io:1} El número de casos prueba está dado en la primer línea de la entrada.

\begin{figure}[H]
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{haskell}
    {codigo/haskell/sample-input-output-1.hs}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{cpp}
    {codigo/cpp/sample-input-output-1.cpp}
\end{minipage}
\end{figure}
\begin{figure}[H]
\centering
\begin{minipage}{0.2\textwidth}
    \inputminted[fontsize=\small]{text}{codigo/txt/sample-input-output-1.txt}
\end{minipage}
\end{figure}

\newpage
\begin{itemize}

\item En la línea \texttt{1} del módulo \hsCode{Control.Monad} se importan las funciones\\
\hsCode{replicateM_ :: Applicative m => Int -> m a -> m ()} y\\
\hsCode{guard :: Alternative f => Bool -> f ()}.\\
Donde \hsCode{replicateM_ n act} lleva a cabo una acción $n$ veces descartando los
resultados\footnote{
    En Haskell es una convención que cuando se descartan los resultados de una función que está
    envuelta en unn contexto monádico, el nombre de la función tiene de sufijo un guión bajo. Esto
    es útil cuando solo es importante los \emph{efectos secundarios} del cómputo monádico en
    vez de su resultado \emph{per se}.
}. Y \hsCode{guard} es utilizada como una condicional de fallo.

\item De la línea \texttt{3} a \texttt{25} empieza el bloque \hsCode{do} utilizado para las
operaciones de entrada y salida.

\item En la línea \texttt{8} se lee una línea de la entrada estándar; que es el número de casos,
que a su vez es es transformado a un tipo de dato \hsCode{IO Int}.

La función \hsCode{fmap :: (a -> b) -> f a -> f b}\\ tranforma el contenido del tipo envuelto en un
contexto monádico dada una función. Se ocupa el sinónimo infijo \texttt{<\$>} de \hsCode{fmap}.
Con ayuda de la función \hsCode{read :: Read a => String -> a} se parsea a un tipo de
dato \hsCode{Int} el \hsCode{String} leído.

\item En la línea \texttt{10} la función \hsCode{replicateM_} ejecuta la mónada de abajo $n$ veces
descartando el resultado, esto se hace como una ligera optimización ya que solo nos interesan
los efectos secundarios (IO).

\item En la línea \texttt{14} se lee una línea de la entrada estándar, y con la función auxiliar
\hsCode{parse} se transforma la cadena de números separada por espacios en una lista de tipo
\hsCode{[Int]}. La función \hsCode{parse} es la composición de dos funciones, primero
\hsCode{words :: String -> [String]} que separa una cadena en una lista de palabras donde los
`delimitadores' son espacios en blanco, después cada cadena se convierte a un tipo de dato
\hsCode{Int}.

\item En la línea \texttt{17} la función \hsCode{guard :: Alternative f => Bool -> f ()} se usa
para señalar un posible error en la mónada \hsCode{IO} en el caso de que no sean dos números
en la línea leída.

\item En la línea \texttt{19} en la expresión \hsCode{let} se usa para tener la suma de los valores
de entrada en la asignación \hsCode{result}.

\item Finalmente en la línea \texttt{22} se imprime en la salida estándar con\\
\hsCode{putStrLn :: String -> IO ()} el resultado, pero primero con la función
\hsCode{show :: a -> String} se transforma el valor de \texttt{result} a \hsCode{String}.

\end{itemize}


\pagebreak
\item \label{io:2} Múltiples casos prueba, son terminados con caracteres especiales.

\begin{figure}[H]
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{haskell}
    {codigo/haskell/sample-input-output-2.hs}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{cpp}
    {codigo/cpp/sample-input-output-2.cpp}
\end{minipage}
\end{figure}
\begin{figure}[H]
\centering
\begin{minipage}{0.3\textwidth}
    \inputminted[fontsize=\small]{text}{codigo/txt/sample-input-output-2.txt}
\end{minipage}
\end{figure}

\newpage
Se tratará la entrada y salida \textit{orientada a líneas} con la función \hsCode{interact}.

Analicemos parte por parte las líneas \texttt{3} a \texttt{12}.\\
La función \hsCode{interact :: (String -> String) -> IO ()} toma una función de
tipo \hsCode{(String -> String)} como argumento, la \textit{entrada} estándar es pasada a ésa
función como argumento, y la cadena resultante es pasada a la salida estándar.

Acto seguido, se tiene la función \texttt{(\$)} que es un operador infijo con asociatividad
izquierda, esto para tener mejor legibilidad cuando se tienen argumentos largos.

Dado que se procesará linea por línea de la entrada, es bastante común tratar el flujo de la
entrada como una lista de líneas, así que para hacer eso se divirá todo la cadena de entrada en
líneas\footnote{Donde `lìneas' es un sinónimo de \hsCode{[String].}}.
Consideremos las funciones\\ \hsCode{lines :: String -> [String]} y
\hsCode{unlines :: [String] -> String}, donde\\ \hsCode{lines} divide la cadena en una lista de
cadenas cuando se encuentra un caracter de salto de línea, \hsCode{unlines} es la operación inversa
de \hsCode{lines}, une líneas y después añade un caracter de salto de línea a cada cadena.

Pongamos total atención a la siguiente composición de funciones\\
\hsCode{unlines . map parse . takeWhile (/= "0 0") . lines}.\\
La función \hsCode{map parse} será la responsable de que la cadena en turno la tranformará a la
`respuesta' del problema.

Mientras que \hsCode{takeWhile (/= "0 0")} indica que se seguirá procesado hasta que la cadena
leída sea diferente de \texttt{"0 0"}.

El patrón \hsCode{unlines . f . lines} es un patrón bastamte común donde \hsCode{f} puede ser una
función o composición de funciones donde\\ \hsCode{f :: [String] -> [String]}.

En la línea \texttt{16} solamente es la composición de funciones donde \hsCode{process} es
la encargada del `cálculo' o `algoritmo', y \hsCode{show} tranforma el tipo de dato
a \hsCode{String}.


\pagebreak
\item \label{io:3}Múltiples casos prueba, son terminados por la señal de EOF (\emph{End Of File}).

\begin{figure}[H]
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{haskell}
    {codigo/haskell/sample-input-output-3.hs}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\centering
\inputminted[frame=single, framesep=10pt, fontsize=\scriptsize, linenos, numbersep=-10pt, framesep=18pt]{cpp}
    {codigo/cpp/sample-input-output-3.cpp}
\end{minipage}
\end{figure}
\begin{figure}[H]
\centering
\begin{minipage}{0.2\textwidth}
    \inputminted[fontsize=\small]{text}{codigo/txt/sample-input-output-3.txt}
\end{minipage}
\end{figure}

De manera análoga al inciso anterior \ref{io:2}, la única diferecia es que se procesará de manera
\textit{infinita}, es decir hasta que se dé la señal de EOF.

\end{enumerate}

\pagebreak
\section{Problemas}
En esta sección se resolverán 4 problemas relacionados con \textit{string matching} usando el
algoritmo KMP y la función de error. Se resolverán los problemas usando C++ y Haskell.

Los problemas que se presentan a continuación se obtuvieron de un juez en línea\footnote{
    Los jueces en línea (\textit{online judges}) son ambientes en línea en donde se prueba el
    código del problema a resolver. Cuando hay un concurso, los jueces muestran listado de
    clasificación en tiempo real donde aparecen los usuarios que tengan el mayor número de
    problemas aceptados y tengan el menor tiempo de ejecución del problema en particular.
} llamado {\fontfamily{lmss}\selectfont SPOJ}.
{\fontfamily{lmss}\selectfont SPOJ} \textit{(Sphere Online Judge)} es un sitio web de concursos
de programación automatizado. Cuenta con un gran número de problemas para entrenar y hacer
concursos locales, además de que acepta las soluciones en varios lenguajes de programación
(incluyendo Haskell). Resolver los problemas en Haskell puede llegar a ser un reto.

Por lo general los problemas son resultos en Java, C y C++.

\subsection{Encontrar el factor de repetición de una cadena}
Antes de empezar, se enunciará un problema tomado del
\emph{Introduction to Algorithms}\cite{cormen_2009} de la página 1012.

\begin{tcolorbox}
\hypertarget{repetitions-facor}{32-1}   
\textbf{String matching based on repetition factors.}
Let $y^i$ denote the concatenation of string $y$ with itself $i$ times. For example,
$(\texttt{ab})^3 =$ \texttt{ababab}. We say that a string $x \in \Sigma^*$
\textbf{has repetition factor} $r$ if $x = y^r$ for some string $y \in \Sigma^*$ and some $r > 0$.
Let $\rho(x)$ denote the largest $r$ such that $x$ has repetition factor $r$.
Give an efficient algorithm that takes as input a pattern $P[1 \ldots m]$ and computes the value
$\rho(x)$ for $i = 1,2,\ldots,m$. What is the running time of your algorithm?
\end{tcolorbox}
    
Lo primero que se debe de hacer es calcular la función de error $\pi$ teniendo una complejidad en
tiempo de $\Theta(m)$ y lineal en espacio. Teniendo calculada $\pi$, consideremos $m$ la longitud
del patrón y supongamos que $r = m - \pi[m]$ es la longitud de la $i$-esima raíz del patrón y que
$\pi[i] = i - r$ donde $r \mid m$ es la $\frac{i}{k}$-ésima concatenación de la raíz del patrón
hasta la $i$-ésima posición. Conlcuyendo así que $\rho(P) = \frac{m}{r}$.

En otro caso, supongamos que no se cumple lo anterior, i.e., que $r \nmid m$ entonces su factor de
repetición forzosamente debe ser 1. Por contradicción, supongamos que tiene un factor de repetición
mayor estrico que 1 lo que significaría que tendría que habría una cadena $y^r$ y que
$\pi[i] \geq \vert x^{r-1} \vert$, pero significaría que podríamos escribir a $x$ concatenada $r$
veces. $\Rightarrow\!\Leftarrow$.

\noindent\rule{\textwidth}{1pt}

Es aquí cuando lo bonito de la programación competitiva y resolver `ejercicios teóricamente' se
juntan. Ése problema es lo mismo a resolver el siguiente, y aún mejor, en un juez en línea que
puede ``probar'' la implementación con múltipleas casos pruebas y, considerando ciertas
restricciones que nos \textit{forzará a usar} un algoritmo \textit{óptimo}.


La especificación del problema dice lo siguiente:

\includepdf[pages=-]{problemas/pdf/FINDSR.pdf}

\subsubsection{Entrada}
La entrada se lee como se indica en el caso \ref{io:2}, la única diferencia es que
\hsCode{takeWhile} toma de argumento \hsCode{"*"}.

Como cada cadena será de longitud de a lo más $10^5$, según la tabla
\ref{cap5:tabla:complejidades} es viable resolver el problema usando la función de error.

\subsubsection{Salida}
Para cada caso prueba \textit{(input)} se debe imprimir en la salida estándar una sola línea con un
número $n$ siendo ésta la raíz de la cadena, es decir, el número de veces que está concatenada la
cadena consigo misma.

\subsubsection{Ejemplos}
\begin{itemize}
\item Consideremos la entrada $x =$ \texttt{abcabcabcabc} y sobre ésta se construye la función
de error, 
\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-13}
$i$      & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          & 10         & 11         & 12         \\ \hline
$P[i]$   & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{a} & \texttt{b} & \texttt{c} \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          \\ \cline{2-13} 
\end{tabular}
\end{table}

Siendo $\vert x \vert = 12$ y el último elemento de la función de error es $\pi[m] = 9$ y sea
$r = 12 - 9 = 3$. Se conluye que la raíz de la cadena es de longitud \textbf{3} y su factor de
repetición es $\rho(x) = \frac{12}{3} =$ \textbf{4}. Concluyendo así que
\texttt{(abc)}$^4 = $ \texttt{abcabcabcabc}.

\item Consideremos la entrada $x =$ \texttt{acbdefgh012} y sobre ésta se construye la función
de error, 
\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-12}
$i$      & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          & 10         & 11         \\ \hline
$P[i]$   & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{d} & \texttt{e} & \texttt{f} & \texttt{g} & \texttt{h} & \texttt{0} & \texttt{1} & \texttt{2} \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          \\ \cline{2-12} 
\end{tabular}
\end{table}

Siendo $\vert x \vert = 11$ y el último elemento de la función de error es $\pi[m] = 0$ y sea
$r = 11 - 0 = 11$. Teniendo que su factor de repetición es $\rho(x) = $ \textbf{1}. Concluyendo
así que\texttt{(acbdefgh012)}$^1 = $ \texttt{acbdefgh012}.

\item Consideremos la entrada $x =$ \texttt{aaaaaaaaaa} y sobre ésta se construye la función
de error, 
\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-11}
$i$      & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          & 10         \\ \hline
$P[i]$   & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} \\ \hline
$\pi[i]$ & 0          & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          \\ \cline{2-11} 
\end{tabular}
\end{table}

Siendo $\vert x \vert = 10$ y el último elemento de la función de error es $\pi[m] = 9$ y sea
$r = 10 - 9 = 1$. Se conluye que la raíz de la cadena es de longitud \textbf{1} y su factor de
repetición es $\rho(x) = \frac{10}{1} =$ \textbf{1}. Concluyendo así que
\texttt{(a)}$^{10} = $ \texttt{aaaaaaaaaa}.
\end{itemize}
\newpage

\subsubsection{Implementación en C++}
\inputminted[linenos, frame=lines, fontsize=\footnotesize]{cpp}{problemas/cpp/FINDSR.cpp}

\begin{itemize}
\item En la línea \texttt{1} se agrega la cabecera \texttt{iostream} que define la entrada y salida
estándar. En la línea \texttt{2} se agrega la cabecera \texttt{vector} que son contenedores de
arreglos dinámicos.

\item De línea \texttt{6} a \texttt{19} es la implementación de la función de error.

\item En la línea \texttt{23} es la parte importante sobre leer la entrada; se leerá hasta EOF y si
la cadean leída es diferente de \texttt{*}.

\item En la línea \texttt{24} se crea un vector con la función de error con el patrón \texttt{s}, y
en la línea \texttt{28} se obtiene la posible longitud de la $k$-ésima raíz del patrón.

\item Y de la línea \texttt{30} a \texttt{33} es cuando se hace la validación previamente analizada.
\end{itemize}

\subsubsection{Implementación en Haskell}
\inputminted[linenos, frame=lines]{haskell}{problemas/haskell/FINDSR.hs}

\begin{itemize}
\item En la línea \texttt{1} del módulo \hsCode{Data.Array} importamos solamente el tipo
\hsCode{Array} sin ninguno de sus constructores, la función \hsCode{bounds :: Array i e -> (i, i)}
que devuelve los límites del arreglo en cual fue construido,\\
\hsCode{listArray :: Ix i => (i, i) -> [e] -> Array i e} que construye un arreglo donde el primer
argumentos son los límites inferiores y superiores, y una lista de valores devolviendo valores
con un orden indexado,\\
\hsCode{(!) :: Ix i => Array i e -> i -> e}  regresa el valor de un índice dado en el arreglo.

\item De la línea \texttt{6, 7} la función \hsCode{parse} será la responsable de tomar la cadena en
turno, tomar el resultado de \hsCode{process} y convertirlo al tipo \hsCode{String}.

En el punto siguiente se hablará sobre la función \hsCode{process :: String -> Int}, pero básicamente es
la que ``hará el algoritmo'', lo importame aquí es el tipo \hsCode{Int}, y es por eso que se hizo
la función \hsCode{parse :: String -> String}.

\item De igual manera de las líneas \texttt{8} a \texttt{16} en la expresión \hsCode{let ... in ...}
en la línea \texttt{10} se calcula la función de error de la cadena de entrada, en la \texttt{11}
se obtienen los límites del arreglo siendo la segunda entrada tamaño del arreglo, y en la línea
\texttt{12} se obtiene el último elemento del arreglo y después su índice. En la línea \texttt{13}
se obtiene la posible longitud de la $k$-ésima raíz del patrón. Finalmente de la línea \texttt{14}
a \texttt{16} es cuando se hace la validación previamente analizada.

\item De la línea \texttt{19} a \texttt{29} es la implementación de función de error.
\end{itemize}

\subsubsection{Resultado del juez}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{spoj/FINDSR-accepted-cpp-haskell}
\caption{El código fue aceptado por el juez en Haskell y C++}
\end{figure}

\newpage


\subsection{Ver si una cadena es una rotación cíclica de otra}
El siguientea problema también fue tomado del \emph{Introduction to Algorithms}\cite{cormen_2009}
de la página 1012.
\begin{tcolorbox}
\hypertarget{cyclic_rotation}{32.4-7}
Give a linear-time algorithm to determine whether a text $T$ is a cyclic rotation of another string
$T'$ . For example, \texttt{arc} and \texttt{car} are cyclic rotations of each other.
\end{tcolorbox}

Descartemos el caso en que la longitud de $T$ y $T'$ sean diferentes porque no podría ser una
rotación cíclica. Entonces $\vert T \vert = \vert T' \vert$, sea $S = TT$ el texto donde $T$ está
concatenado dos veces, y $P = T'$ el patrón. Usando el algoritmo de Knuth-Morris-Pratt se buscará
el patrón $P$ en $S$ en tiempo lineal.

Supongamos que $P$ aparece en $T$ desplazado $s$ posiciones a la izquierda donde
$0 \leq s < \vert P \vert$. Si $s = 0$ entonces $T = T'$, el caso interesante es cuando $s > 0$,
teniendo así que $T[0 \ldots s]$ es sufijo de $T'$ y $T[s+1 \ldots m]$ es prefijo de $T$. 

\noindent\rule{\textwidth}{1pt}

\subsubsection{Entrada}
La entrada se lee como se indica en el caso \ref{io:1}.

\subsubsection{Salida}
Solo se deberá mostrar en la salida estándar \texttt{Si} o \texttt{No} dependiendo si es una
rotación cíclica.

\subsubsection{Ejemplos}
Dado que ambas cadenas son de la misma longitud se hará lo siguiente; $s = qq$ donde $s$ será el
texto y $p$ el patrón. Entonces con el algoritmo dee Knuth-Morris-Pratt se buscará $p$ en $s$.

\begin{itemize}
\item \texttt{abc} es una rotación cíclica de \texttt{cab} porque \texttt{cab} $\mapsto$
\texttt{abc}. Se muestra en la siguiente tabla de manera gráfica la idea.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\texttt{c}                   &  \cellcolor{green}\texttt{a} &  \cellcolor{green}\texttt{b} &
\cellcolor{green} \texttt{c} &  \texttt{a}                  & \texttt{b}                   \\\hline
\end{tabular}
\end{table}

\item Claramente \texttt{abab} no es rotación cíclica de \texttt{aabb}.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\texttt{a} & \texttt{b} & \texttt{a} &\texttt{b} & \texttt{a} & \texttt{b} & \texttt{a} & \texttt{b} \\\hline
\end{tabular}
\end{table}
\end{itemize}

\includepdf[pages=-]{problemas/pdf/EC_WORLD.pdf}

\subsubsection{Implementación en C++}
\inputminted[linenos, frame=lines, fontsize=\footnotesize]{cpp}{problemas/cpp/EC_WORLD.cpp}
\begin{itemize}
\item De línea \texttt{6} a \texttt{19} es la implementación de la función de error.

\item De línea \texttt{21} a \texttt{38} es la implementación del algoritmo Knuth-Morris-Pratt.

\item En línea \texttt{43} se lee el número de casos, y en la \texttt{44} se itera \texttt{t} hasta
que sea 0 y como cualquier valor no cero en \texttt{while} lo toma como falso para la iteración.

\item De la línea \texttt{47} a \texttt{52} es cuando hace la validación dicha en el análisis.

\end{itemize}

\newpage

\subsubsection{Implementación en Haskell}
\inputminted[linenos, frame=lines]{haskell}{problemas/haskell/EC_WORLD.hs}

Muchas veces algunos jueces (o problemas) no aceptan ciertos lenguaje, y en este caso el que
diseñó el problema y lo subió en SPOJ, no puso a Haskell para este problema. Pero aún así se hará.

Recordando la primera manera \ref{io:1} de leer la entrada, se seguirá ese camino.

\begin{itemize}
\item La única diferencia sería en la línea \texttt{8} con el uso de la función \hsCode{liftM2}.\\
\hsCode{liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r} toma dos valores mónadicos y
combina sus contenidos usando otra función. Ejemplo:
\begin{minted}[frame=single]{haskell}
addM :: Maybe Int -> Maybe Int -> Maybe Int
addM mx my = do
    x <- mx
    y <- my
    return (x + y)
\end{minted}

\begin{minted}[frame=single]{haskell}
add :: Maybe Int -> Maybe Int -> Maybe Int
add = liftM2 (+)
\end{minted}

\item De la línea \texttt{10} a \texttt{16} es see crea la función
\hsCode{process :: [String] -> String}, donde por medio de caza de patrones se trabaja con una
lista de dos elementos, acto seguido en la expresión \hsCode{let ... in ..} se busca la ocurrencia
del patrón \texttt{p} en \texttt{s} y al final con la función
\hsCode{null :: Foldable t => t a -> Bool} se verifica si la lista es vacía.  

\item De la línea \texttt{20} a \texttt{44} es la implementación del algoritmo Knuth-Morris-Pratt
funcionalmente.
\end{itemize}

\subsubsection{Resultado del juez}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{spoj/EC_WORLD-accepted-cpp}
\caption{El código fue aceptado por el juez en C++}
\end{figure}

\newpage


\subsection{Extender una cadena a su palíndromo más corto}

\subsubsection{Análisis}
En este problema lo \textit{realmente importante} empieza en el tercer párrafo, que resumiendo es:

\begin{tcolorbox}
Dada una cadena, producir el palíndromo\footnote{Un palíndromo es una palabra o frase que se lee
igual en un sentido que en otro. Por ejemplo: arenera, oso, radar, sometemos, etc.} más corto que
puede ser formado agregando cero o más caracteres al final de la cadena.
\end{tcolorbox}

Una forma ingenua de resolver este problema es simplemente concatenando la cadena original $s$
con su reversa $s^R$, i.e., $t = ss^R$ donde $t$ ya es un palíndromo, y a pesar de que resuelve el
problema no se asegura que sea el palíndromo más corto.

Para mostrarlo tomemos una cadena arbitraria $s = $ \texttt{recono} y $s^R =$ \texttt{onocer}
quedando $t = $ \texttt{reconoonocer} y $t$ es un palíndromo pero hay un palíndromo más corto
$t' = $ \texttt{reconocer}. Esto fue agregando de sufijo \texttt{cer} a \texttt{recono}. 
Por lo tanto debe de haber una forma mejor de atacar el problema.

Consideremos la función de error utilizada en KMP, como por hipótesis del problema la cadena solo
consiste de letras mayúsculas y minúsculas, se puede usar un tipo de ``separador'' al procesar lo
siguiente; sea $r = s^R$\texttt{\$}$s$ donde $r$ es la concatenación de la reveresa de la cadena de
entrada concatenada con el símbolo \texttt{\$} como separador, y la cadena original.

Entonces se procesará $r$ con la función de error, y ésta indicará el prefijo más largo de $s^R$
que es sufijo de $s$, denominemos a tal la subcadena como $s'$ tal que $s' \sqsubset s^R$ y
$s' \sqsupset s$, esto para saber de antemano la subcadena que se traslapa en $s$ y $s^R$. Para
obtener $s'$ tomemos $n = \vert t \vert$ y $\pi$ la función de error donde $\pi[n] = k$ es la 
longitud de $s'$. Para finalmente tener el palíndromo más pequeño se toma la cadena original $s$
concatenada con $u = s^R[k \ldots]$ donde $u$ es la subcadena de $s^R$ desde $k$.

La complejidad del algoritmo es $\Theta(m)$ donde $m$ es el tamaño de la cadena de entrada tanto
en espacio y tiempo, esto es por construir la función de error y obtener la reversa de una cadena.

\subsubsection{Entrada}
La entrada será leída línea por línea hasta EOF como se indica en \ref{io:3} y la entrada será
sobre un alfabeto de \texttt{[a-z]|[A-Z]} entonces serán representados en ASCII.

\subsubsection{Salida}
Una sola línea con el palíndromo de más corto.

\subsubsection{Ejemplos}
\begin{itemize}
\item Sea $s = $ \texttt{aaaa}, $s^R =$ \texttt{aaaa} y finalmente
$r = s^R$\texttt{\$}$s =$ \texttt{aaaa\$aaaa} y se construye la función de error con $r$ quedando,

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|}
\cline{2-10}
$i$      & 1          & 2          & 3          & 4          & 5           & 6          & 7          & 8          & 9          \\ \hline
$P[i]$   & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{\$} & \texttt{a} & \texttt{a} & \texttt{a} & \texttt{a} \\ \hline
$\pi[i]$ & 0          & 1          & 2          & 3          & 0           & 1          & 2          & 3          & 4          \\ \cline{2-10} 
\end{tabular}
\end{table}
Para obtener $s'$ tomemos $n = \vert r \vert = 9$ y en $\pi[9] = 4$ donde $\vert s' \vert = 4$.\\
Siendo el palíndromo más corto como
$u = s \cdot s^R[4 \ldots] =$ \texttt{aaaa}$\cdot \varepsilon$ = \texttt{aaaa}.

\item Sea $s = $ \texttt{abba}, $s^R =$ \texttt{abba} y finalmente
$r = s^R$\texttt{\$}$s =$ \texttt{abba\$abba} y se construye la función de error con $r$ quedando,

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|}
\cline{2-10}
$i$      & 1          & 2          & 3          & 4          & 5           & 6          & 7          & 8          & 9          \\ \hline
$P[i]$   & \texttt{a} & \texttt{b} & \texttt{b} & \texttt{a} & \texttt{\$} & \texttt{a} & \texttt{b} & \texttt{b} & \texttt{a} \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 1          & 0           & 1          & 2          & 3          & 4          \\ \cline{2-10} 
\end{tabular}
\end{table}
Para obtener $s'$ tomemos $n = \vert r \vert = 9$ y en $\pi[9] = 4$ donde $\vert s' \vert = 4$.\\
Siendo el palíndromo más corto como
$u = s \cdot s^R[4 \ldots] =$ \texttt{abba}$\cdot \varepsilon$ = \texttt{abba}.

\item Sea $s = $ \texttt{amanaplanacanal}, $s^R =$ \texttt{lanacanalpanama} y finalmente\\
$r = s^R$\texttt{\$}$s =$ \texttt{lanacanalpanama\$amanaplanacanal} y se construye la función de
error con $r$ quedando,

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-17}
$i$      & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9          & 10         & 11         & 12         & 13         & 14         & 15         & 16          \\ \hline
$P[i]$   & \texttt{l} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{c} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{l} & \texttt{p} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{m} & \texttt{a} & \texttt{\$} \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 0          & 1          & 0          & 0          & 0          & 0          & 0          & 0          & 0           \\ \cline{2-17} 
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-16}
$i$      & 17         & 18         & 19         & 20         & 21         & 22         & 23         & 24         & 25         & 26        & 27          & 28         & 29         & 30         & 31          \\ \hline
$P[i]$   & \texttt{a} & \texttt{m} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{p} & \texttt{l} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{c} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{l}  \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 0          & 0          & 0          & 1          & 2          & 3          & 4          & 5          & 6          & 7          & 8          & 9           \\ \cline{2-16} 
\end{tabular}
\end{table}
Para obtener $s'$ tomemos $n = \vert r \vert = 31$ y en $\pi[31] = 9$ donde $\vert s' \vert = 9$.\\
Siendo el palíndromo más corto como $u = s \cdot s^R[9 \ldots] =$\\
\texttt{amanaplanacanal}$\cdot$\texttt{panama} = \texttt{amanaplanacanalpanama}.

\item Sea $s = $ \texttt{xyz}, $s^R =$ \texttt{zyx} y finalmente
$r = s^R$\texttt{\$}$s =$ \texttt{xyz\$zyx} y se construye la función de error con $r$ quedando,

\begin{table}[H]
\centering
\begin{tabular}{c|c|c|c|c|c|c|c|}
\cline{2-8}
$i$      & 1          & 2          & 3          & 4           & 5          & 6          & 7          \\ \hline
$P[i]$   & \texttt{z} & \texttt{y} & \texttt{x} & \texttt{\$} & \texttt{x} & \texttt{y} & \texttt{z} \\ \hline
$\pi[i]$ & 0          & 0          & 0          & 0           & 0          & 0          & 1          \\ \cline{2-8} 
\end{tabular}
\end{table}
Para obtener $s'$ tomemos $n = \vert r \vert = 7$ y en $\pi[7] = 1$ donde $\vert s' \vert = 1$.\\
Siendo el palíndromo más corto como
$u = s \cdot s^R[1 \ldots] =$ \texttt{xyz}$\cdot$\texttt{yx} = \texttt{xyzyx}.

\end{itemize}

\includepdf[pages=-]{problemas/pdf/EPALIN.pdf}

\subsubsection{Implementación en C++}
\inputminted[linenos, frame=lines]{cpp}{problemas/cpp/EPALIN.cpp}

\begin{itemize}
\item En la línea \texttt{24} se hace una copia de la línea que se leyó
\item En la línea \texttt{26} se crea la cadena $r$.
\item En la línea \texttt{31, 32} se acompleta la cadena original para que sea un palíndromo.
\end{itemize}

\subsubsection{Implementación en Haskell}
\inputminted[linenos, frame=lines]{haskell}{problemas/haskell/EPALIN.hs}

\begin{itemize}
\item En la línea \texttt{8} se saca la reversa de la cadena de entrada, en la línea \texttt{9}
se crea la cadena $r$, en la línea \texttt{10} se crea la función de error. Finalmente en la línea
\texttt{13} con la \hsCode{drop :: Int -> [a] -> [a]} que regresa el sufijo de una lista
\texttt{xs} después de los primeros $n$ elementos, se obtiene la cadena faltante para completar el
palíndromo y en la línea \texttt{14} se concatena \texttt{xs} la cadena anterior.
\end{itemize}

\subsubsection{Resultado del juez}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{spoj/EPALIN-accepted-cpp-haskell}
\caption{El código fue aceptado por el juez en Haskell y C++}
\end{figure}

\newpage


\subsection{Encontrar las ocurrencias de un patrón en un texto}

\subsubsection{Análisis}
De los problemas anteriores este es quizás es el uso más \textit{canónico} del algoritmo
Knuth-Morris-Pratt per se, ya que solo se pide encontrar todas las posiciones 0-indexadas de
un patrón en un texto. Lo inlcuí porque ``la trampa'' de este problema es que mucha gente lo
resuelve con el algoritmo \textit{naïve} y simplemente el juez no lo aceptará. La complejidad como
ya se había comentado enteriormente, es $\Theta(m)$ en tiempo el preprocesamiento del patrón y
$\Theta(n)$ en encontrar las ocurrencias, en espacio toma complejidad $O(m)$.

\subsubsection{Entrada}
La entrada será leída línea por línea hasta EOF como se indica en \ref{io:3}, cada caso prueba
consistirá de 3 líneas; la primera será la longitud del patrón, seguida del patrón y después
el texo.

\subsubsection{Salida}
Si hubo una(s) aparición(es) cada una será impresa en pantalla línea por línea. Si no, solamente
se imprirá un salto de línea.

\subsubsection{Ejemplos}
\begin{itemize}
\item El patón es \texttt{na} y el texto es \texttt{banananobano}, y hubo 2 apariciones del patrón
en las posiciones 2 y 4.
\begin{table}[h]
\centering
\begin{tabular}{|c|c|
>{\columncolor[HTML]{F5B7B1}}c|
>{\columncolor[HTML]{F5B7B1}}c|
>{\columncolor[HTML]{D7BDE2}}c|
>{\columncolor[HTML]{D7BDE2}}c|c|c|c|c|c|c|}
\hline
\texttt{b} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{n} & \texttt{a} & \texttt{n} &
\texttt{o} & \texttt{b} & \texttt{a} & \texttt{n} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\item El patón es \texttt{foobar} y el texto es \texttt{foo}, y no hubo ninguna aparición del
patrón.
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
\texttt{f} & \texttt{o} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\item El patón es \texttt{foobarfoo} y el texto es \texttt{barfoobarfoobarfoobarfoobarfoo}, y
hubo 4 apariciones del patrón la posiciones 3, 9, 15 y 21.
\begin{table}[H]
\centering
\hspace*{-3cm}
\footnotesize
\begin{tabular}{|c|c|c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|
>{\columncolor[HTML]{AED6F1}}c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} &
\texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} &
\texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} &
\texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} &
\texttt{o} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\hspace*{-3cm}
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|
>{\columncolor[HTML]{ABEBC6}}c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} &
\texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} &
\texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} &
\texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} &
\texttt{o} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\hspace*{-3cm}
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|
>{\columncolor[HTML]{F9E79F}}c|c|c|c|c|c|c|c|}
\hline
\texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} &
\texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} &
\texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} &
\texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} &
\texttt{o} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\hspace*{-3cm}
\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|
>{\columncolor[HTML]{EDBB99}}c|c|}
\hline
\texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} &
\texttt{a} & \texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} &
\texttt{r} & \texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} &
\texttt{f} & \texttt{o} & \texttt{o} & \texttt{b} & \texttt{a} & \texttt{r} & \texttt{f} &
\texttt{o} & \texttt{o} \\ \hline
\end{tabular}
\end{table}

\end{itemize}

\includepdf[pages=-]{problemas/pdf/NHAY.pdf}

\subsubsection{Implementación en C++}
\inputminted[linenos, frame=lines, fontsize=\footnotesize]{cpp}{problemas/cpp/NHAY.cpp}

\subsubsection{Implementación en Haskell}
\inputminted[linenos, frame=lines]{haskell}{problemas/haskell/NHAY.hs}

\newpage
\begin{itemize}
\item Al ser un programa orientado a líneas, solo se prestará atención a la función
\hsCode{process} y \hsCode{parse}.

En la función \hsCode{parse} se usa para \textit{procesar} de tres en tres líneas y cada caso
prueba verlo como una sola tupla. En la función \hsCode{process} en la línea \texttt{12} busca
las apariciones del patrón en el texto, seguido en la línea \texttt{14} verifica si es una lista
vacía, si lo es solamente regresa un salto de línea, si no con la función
\hsCode{intercalate :: [a] -> [[a]] -> [a]} que inserta el primer argumento entre cada elemento
de la lista y concatena el resultado, pone un salto de línea entre cada índice de cada ocurrencia.
\end{itemize}

\subsubsection{Resultado del juez}
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{spoj/NHAY-accepted-cpp-haskell}
\caption{El código fue aceptado por el juez en Haskell y C++}
\end{figure}
